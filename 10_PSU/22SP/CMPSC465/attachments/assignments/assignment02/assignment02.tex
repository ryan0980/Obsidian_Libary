\documentclass[11pt]{article}

\usepackage{CMPSC465}
\usepackage{enumitem}
\usepackage{algpseudocode}
\usepackage{tikz}

\def\title{Assignment 02}

\def\defeq{\mathrel{\mathop:}=}
%\usepackage{algpseudocode}
%\usepackage{algorithm}
\usepackage[ruled,noline]{algorithm2e}
%\usepackage{amsthm}
\newcommand\nonl{%
  \renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line
  
\newcommand{\aaa}[1]{\hspace{0.65cm}\parbox[t]{15.3cm}{#1}}
\newcommand{\aab}[1]{\hspace{1.15cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aac}[1]{\hspace{1.65cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aad}[1]{\hspace{2.15cm}\parbox[t]{15.0cm}{#1}}
\newcommand{\aaA}[2]{\hspace{0.5cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaB}[2]{\hspace{1.0cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaC}[2]{\hspace{1.5cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\aaD}[2]{\hspace{2.0cm} {\tikz[overlay] \draw (0.1, -0.1) -- (0.1, #1 * -1.5em + 0.6em);} \parbox[t]{15.0cm}{#2}}
\newcommand{\xxx}{\par\vspace{0.1cm}}

\begin{document}
\maketitle

\section*{Due: Friday 09:00 am, Jan.\ 28, 2022}

\paragraph*{Instructions:}

You may work in groups of up to three people to solve the homework.
You must write your own solutions and explicitly acknowledge everyone whom 
you have worked with or who has given you any significant ideas about your solutions. 
You may also use books or online resources to help solve homework problems.  
All consulted references must be acknowledged. The acknowledgements need to be made by answering Problem~1 below.

You are encouraged to solve the problem sets on your own using only the textbook and lecture notes as a reference. This will give you the best chance of doing well on the exams. Relying too much on the help of group members or on online resources will hinder your performance on the exams.

Submissions being late in 2 hours will be accepted with a 20\% penalty. Submissions late more than 2 hours will receive 0. There will be no exceptions to this policy, as we post the solutions soon after the deadline. 

For the full policy on assignments, please consult the syllabus.

\paragraph*{Formatting:} Start a new page for each problem.

\paragraph*{Describing an Algorithm:} Please make sure you use plain wording to explain your algorithm. It is always a good practice to start with a summary of the high-level idea of your algorithm to ease graders understand your solution quickly. Then, explain your algorithm, using plain wording and including enough details.

The use of pseudo-code is optional, and it is your decision. No matter you use it or not, above description in words is always required. The pseudo-code has its own advantage in explaining structured (i.e., if-else, for-loop, recursive functions, etc) algorithms and in putting details in the right place. If you think pseudo-code better explains your algorithm, and/or helps graders understand your solution, and/or contains more details not included in the plain-wording description, then use pseudo-code. If you think everything is already clearly explained in the description with words, then you don't need to include pseudo-code. An algorithm that is only written in pseudo-code (i.e., missing above plain-wording description) is not acceptable, as it is extremely hard to read just pseudo-code without any explanation.

Here is a general situation that may help you decide whether to use pseudo-code or not. An algorithm could be ``designed from scratch'', i.e., you will need to come up with the step-by-step procedure. This usually involves in implementing a function with clear input and output. In this case, including pseudo-code usually helps. All algorithm we've seen so far (e.g., merge-two-sorted-arrays, merge-sort, etc) falls in this category. Second, an algorithm could also be ''transformed into another algorithm'', i.e., you use an existing algorithm to solve this problem. In this case you usually don't need to include pseudo-code but to describe how to transform one problem into the other. We will see such examples soon.

\begin{qunlist}

\q{0}{Acknowledgements. }
	The assignment will receive a 0 if this question is not answered.
\begin{enumerate}
	\item If you worked in a group, list the members of the group. Otherwise, write ``I did not work in a group.''
	\item If you received significant ideas about your solutions from anyone not in your group, list their names here. Otherwise, write ``I did not consult  anyone except my group members''.
	\item List any resources besides the course material that you consulted in order to solve the material. If you did not consult anything, write ``I did not consult any non-class materials.''
\end{enumerate}

% Qimin
\q{10}{}
Solve each of the following recursions using master's theorem.
Give the closed form of $T(n)$ in Big-Theta notation; you don't need to show your middle steps.
\begin{enumerate}
\item $ T(n) = 8 \cdot T(n/2) + 100 \cdot n^3$.
\item $ T(n) = 8 \cdot T(n/2) + 1000 \cdot n^{3.5}$.
\item $ T(n) = 16 \cdot T(n/2) + n \cdot \log(n)$
\item $ T(n) = 2 \cdot T(n/2) + n \cdot \log(n)$.
\item $ T(n) = 8 \cdot T(n/2) + n^{3.5} \cdot \log^2(n)$.
\end{enumerate}

% Tianyang
\q{10}{}
Suppose you have $m$ sorted arrays, each with $n$ elements, and you want to combine them into a single sorted array with $mn$ elements. 
\begin{enumerate}
\item If you do this by merging the first two arrays, next with the third, then with the fourth, until in the end with the last one. What is the time complexity of this algorithm, in terms of $m$ and $n$? Please also provide the analysis.
\item Give a more efficient solution to this problem, using divide-and-conquer. What is the running time? Please also provide the analysis.
\end{enumerate}

\q{10}{}
If we add one more partition step in find-pivot function in selecting problem,
and use 3 as the size of each subarray, the algorithm would become:

\begin{minipage}{0.8\textwidth}
	\aaA {6}{function find-pivot~($A$, $k$)}\xxx
	\aab {Partition $A$ into $n/3$ subarrays; }\xxx
	\aab {Let $M$ be the list of medians of these $n/3$ subarrays;}\xxx
	\aab {Partition $M$ into $n/9$ subarrays;}\xxx
	\aab {Let $M'$ be the list of medians of these $n/9$ subarrays;}\xxx
	\aab {return selection($M'$, $\left|M'\right|/2$)}\xxx
	\aaa {end function;}\xxx
\end{minipage}

Analyze the running time of the new selection algorithm with the find-pivot
function described above.


\q{10}{}
Suppose you are given an array $A[1\cdots n]$ of integers which can be
positive, negative or 0. A sub-array is a contiguous sequence of elements from
$A$. In particular, for any two indexes $i$ and $j$ with $1 \leq i \leq j \leq n$,
$A[i\cdots j]$ is the sub-array that starts at index $i$ and ends at $j$.
The sum of the sub-array $A[i\cdots j]$ is the sum of all the numbers it
contains: $A[i] + A[i + 1] + ..... + A[j]$. For example, 
if $A = [5, 1, -3, -2, 4, 0]$, the sum of $A[0\cdots 3]$ is 1 and the sum of $A[1\cdots 4]$ is 0.
Given $A$, design a divide-and-conquer algorithm, running in $O(n\log n)$ time, to find the sub-array of minimum sum. For example, in the array $A = [5, 1, -3, -2, 4, 0]$, the
sub-array of minimum sum is $A[2, 3]$ with sum $-5$. You will need to describe your algorithm (please refer to ``Describing an Algorithm'' on top for more instructions), prove the correctness of your algorithm, and analyze the running time of your algorithm. 



% Mingfu
\q{0}{}
\emph{(NOTE: you don't need to submit your solution for this problem.)}
Consider recurrence relation $T(n) = \Theta(n) + T(a\cdot n) + T(b\cdot n)$, $T(1) = 1$, {$0 < a < 1$, $0< b< 1$}.
Prove the following:
\begin{enumerate}
\item $T(n) = \Theta(n)$, if $a + b < 1$.
\item $T(n) = \Theta(n\cdot \log n)$, if $a + b = 1$.
\end{enumerate}

{\bf Solution.} Assume that the term $\Theta(n)$ in the recursion admits a lower bound of $d_1 n$ and upper bound of $d_2 n$, for large enough $n$.
That is $T(n) \ge d_1n + T(an) + T(bn)$ and $T(n) \le d_2n + T(an) + T(bn)$.

\begin{enumerate}
\item
We first prove that $T(n) = O(n)$, by induction.
Assume that $T(n) \le c_2n$ for large enough $n$, where $c_2 = d_2/(1-a-b)$.
Now we prove that $T(n + 1) \le c_2(n+1)$.
We can write
$$T(n + 1) \le d_2(n+1) + T(a(n+1)) + T(b(n+1)).$$
We have $a(n+1) \le n$ and $b(n+1) \le n$ for large enough $n$ as $a < 1$ and $b < 1$.
By the inductive assumption we have
\begin{eqnarray*}
T(n + 1) & \le & d_2(n+1) + c_2a(n+1) + c_2b(n+1) \\
	      & \le & d_2(n+1) + c_2(a+b)(n+1) \\
	      & =   & (d_2 + c_2(a+b))(n+1) \\
		  & =   & c_2(n+1).
\end{eqnarray*}
It's easy to verify the last equation, i.e., $d_2 + c_2(a+b) = c_2$ with $c_2 = d_2 / (1 - a - b)$.
In fact this is where we determine the value of $c_2$. You can also see why
$a + b < 1$ is required here.
We then prove that $T(n) = \Omega(n)$, by induction.
Assume that $T(n) \ge c_1n$ for large enough $n$, where $c_1 = d_1/(1-a-b)$.
Now we prove that $T(n + 1) \ge c_1(n+1)$.
We can write
\begin{eqnarray*}
T(n + 1) &\ge & d_1(n+1) + T(a(n+1)) + T(b(n+1)) \\
          & \ge & d_1(n+1) + c_1a(n+1) + c_1b(n+1) \\
	      & \ge & d_1(n+1) + c_1(a+b)(n+1) \\
	      & =   & (d_1 + c_1(a+b))(n+1) \\
		  & =   & c_1(n+1).
\end{eqnarray*}
The last equation holds as $d_1 + c_1(a+b) = c_1$ with $c_1 = d_1 / (1 - a - b)$.

\item
We first prove that $T(n) = O(n\log n)$, by induction.
Assume that $T(n) \le c_2n\log n$ for large enough $n$, where $c_2 = -d_2 / (a\log a + b\log b)$.
Now we prove that $T(n + 1) \le c_2(n+1)\log (n+1)$.
We can write
\begin{eqnarray*}
T(n + 1)  & \le & d_2(n+1) + T(a(n+1)) + T(b(n+1)) \\
          & \le & d_2(n+1) + c_2a(n+1)\log (a(n+1)) + c_2b(n+1) \log (b(n+1))\\
          & \le & d_2(n+1) + c_2(a\log a + b\log b)(n+1) + c_2(a+b)(n+1)\log (n+1)\\
          & = & (d_2 + c_2(a\log a + b\log b))(n+1) + c_2(n+1)\log (n+1)\\
		  & =   & c_2(n+1)\log (n+1).
\end{eqnarray*}
The last equation holds as $d_2 + c_2(a\log a+b\log b) = 0$ with $c_2 = -d_2 / (a\log a + b\log b)$.
We then prove that $T(n) = \Omega(n\log n)$, by induction.
Assume that $T(n) \ge c_1n\log n$ for large enough $n$, where $c_1 = -d_1 / (a\log a + b\log b)$.
Now we prove that $T(n + 1) \ge c_1(n+1)\log (n+1)$.
We can write
\begin{eqnarray*}
T(n + 1)  & \ge & d_1(n+1) + T(a(n+1)) + T(b(n+1)) \\
          & \ge & d_1(n+1) + c_1a(n+1)\log (a(n+1)) + c_1b(n+1) \log (b(n+1))\\
          & \ge & d_1(n+1) + c_1(a\log a + b\log b)(n+1) + c_1(a+b)(n+1)\log (n+1)\\
          & = & (d_1 + c_1(a\log a + b\log b))(n+1) + c_1(n+1)\log (n+1)\\
		  & =   & c_1(n+1)\log (n+1).
\end{eqnarray*}
The last equation holds as $d_1 + c_1(a\log a+b\log b) = 0$ with $c_1 = -d_1 / (a\log a + b\log b)$.
\end{enumerate}


\end{qunlist}
\end{document}
